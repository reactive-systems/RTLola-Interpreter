//! This module contains necessary traits and types to interface your datastructures with the interpreter.
//! Most notably, the [EventFactory] trait represents a factory for events such that you can feed events of type [EventFactory::Record] to the monitor.
//! To easy the implementation, there are helper traits like [InputMap] which works together with the [MappedFactory].
//!
//! Note: A struct implementing [EventFactory] for a given type can often be derived. For that take a look at the rtlola-interpreter-macros crate and the [AssociatedEventFactory] trait.

// ######## Traits ############

use std::collections::{HashMap, HashSet};
use std::convert::Infallible;
use std::error::Error;
use std::fmt::{Display, Formatter};
use std::marker::PhantomData;

use itertools::Itertools;
use rtlola_frontend::mir::InputReference;

use crate::monitor::Event;
use crate::{CondDeserialize, CondSerialize, Value, ValueConvertError};

/// This trait provides the functionality to pass inputs to the monitor.
/// You can either implement this trait for your own Datatype or use one of the predefined input methods.
/// See [MappedFactory], [ArrayFactory], and [VectorFactory]
pub trait EventFactory: Sized {
    /// The type from which an event is generated by the input source.
    type Record: Send;

    /// The error type returned by the input source on IO errors or parsing issues.
    type Error: Into<EventFactoryError> + Send + 'static;

    /// Arbitrary type of the data provided to the input source at creation time.
    type CreationData: Clone + Send;

    /// Creates a new input source from a HashMap mapping the names of the inputs in the specification to their position in the event.
    fn new(map: HashMap<String, InputReference>, setup_data: Self::CreationData) -> Result<Self, EventFactoryError> {
        let all = map.keys().cloned().collect::<HashSet<_>>();
        let (i, found) = Self::try_new(map, setup_data)?;
        let found = found.into_iter().collect::<HashSet<_>>();
        let missing: Vec<String> = all.difference(&found).cloned().collect();
        if !missing.is_empty() {
            Err(EventFactoryError::InputStreamUnknown(missing))
        } else {
            Ok(i)
        }
    }

    /// Construction the input for only a subset of the required input streams. Enables the combination of multiple Input implementors into one.
    /// The returned Vector contains the names of the input streams that can be served by this input.
    /// The constructed input should return `Value::None` for all inputs that are unknown to it.
    fn try_new(
        map: HashMap<String, InputReference>,
        setup_data: Self::CreationData,
    ) -> Result<(Self, Vec<String>), EventFactoryError>;

    /// This function converts a record to an event.
    fn get_event(&self, rec: Self::Record) -> Result<Event, EventFactoryError>;
}

/// This trait provides functionality to parse a type into an event.
/// For that, getter functions for the different input streams are provided through the `func_for_input` method.
/// Note: The [AssociatedEventFactory] trait is automatically implemented for all types that implement this trait.
pub trait InputMap: Send {
    /// Arbitrary type of the data provided at creation time to help initializing the input method.
    type CreationData: Clone + Send;
    /// The error returned if anything goes wrong.
    type Error: Into<EventFactoryError> + Send + 'static;
    /// Given the name of an input this function returns a function that given self returns the value for that input.
    fn func_for_input(name: &str, data: Self::CreationData) -> Result<ValueGetter<Self, Self::Error>, Self::Error>;
}

/// A trait to annotate Self with an [EventFactory] that accepts Self as a Record.
pub trait AssociatedEventFactory {
    /// The associated factory.
    type Factory: EventFactory<Record = Self> + Sized;
}

// ######## Implementation ######################

/// A function Type that projects a reference to `From` to a `Value`
pub type ValueGetter<From, E> = Box<dyn (Fn(&From) -> Result<Value, E>)>;

#[derive(Debug)]
/// A generic Error to be used by [EventFactory]s
pub enum EventFactoryError {
    /// Could not find an associated struct field for the input streams.
    InputStreamUnknown(Vec<String>),
    /// The value of the struct field is not supported by the interpreter.
    ///
    /// *Help*: ```TryFrom<YourType> for Value``` has to be implemented.
    ValueNotSupported(ValueConvertError),
    /// The variant of the enum identified by the string was ignored when deriving the Input, yet it was received as an input.
    VariantIgnored(String),
    /// An unknown error occurred
    Other(Box<dyn Error + Send + 'static>),
}
impl Display for EventFactoryError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            EventFactoryError::InputStreamUnknown(name) => {
                write!(
                    f,
                    "The following input stream(s) cannot be served by the input: {}",
                    name.join(", ")
                )
            },
            EventFactoryError::ValueNotSupported(val) => {
                write!(f, "The type of {val:?} is not supported by the interpreter.")
            },
            EventFactoryError::Other(e) => {
                write!(f, "Event Factory Error: {e}.")
            },
            EventFactoryError::VariantIgnored(variant) => {
                write!(f, "Received ignored variant: {variant}.")
            },
        }
    }
}
impl Error for EventFactoryError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            EventFactoryError::InputStreamUnknown(_)
            | EventFactoryError::ValueNotSupported(_)
            | EventFactoryError::VariantIgnored(_) => None,
            EventFactoryError::Other(e) => Some(e.as_ref()),
        }
    }
}
impl From<ValueConvertError> for EventFactoryError {
    fn from(value: ValueConvertError) -> Self {
        EventFactoryError::ValueNotSupported(value)
    }
}
impl From<Infallible> for EventFactoryError {
    fn from(_value: Infallible) -> Self {
        unreachable!()
    }
}

/// An input method for types that implement the [InputMap] trait. Useful if you do not want to bother with the order of the input streams in an event.
/// Assuming the specification has 3 inputs: 'a', 'b' and 'c'. You could implement this trait for your custom 'MyType' as follows:
/// ```
/// use std::fmt::Formatter;
///
/// use rtlola_interpreter::input::{EventFactoryError, InputMap};
/// use rtlola_interpreter::Value;
/// #[cfg(feature = "serde")]
/// use serde::{Deserialize, Serialize};
///
/// #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
/// struct MyType {
///     a: u64,
///     b: Option<bool>,
///     c: String,
/// }
///
/// impl MyType {
///     // Generate a new value for input stream 'a'
///     fn a(rec: &Self) -> Result<Value, EventFactoryError> {
///         Ok(Value::from(rec.a))
///     }
///
///     // Generate a new value for input stream 'b'
///     fn b(rec: &Self) -> Result<Value, EventFactoryError> {
///         Ok(rec.b.map(|b| Value::from(b)).unwrap_or(Value::None))
///     }
///
///     // Generate a new value for input stream 'c'
///     fn c(rec: &Self) -> Result<Value, EventFactoryError> {
///         Ok(Value::Str(rec.c.clone().into_boxed_str()))
///     }
/// }
///
/// impl InputMap for MyType {
///     type CreationData = ();
///     type Error = EventFactoryError;
///
///     fn func_for_input(
///         name: &str,
///         _data: Self::CreationData,
///     ) -> Result<Box<dyn (Fn(&MyType) -> Result<Value, EventFactoryError>)>, EventFactoryError>
///     {
///         match name {
///             "a" => Ok(Box::new(Self::a)),
///             "b" => Ok(Box::new(Self::b)),
///             "c" => Ok(Box::new(Self::c)),
///             x => Err(EventFactoryError::InputStreamUnknown(vec![x.to_string()])),
///         }
///     }
/// }
/// ```
#[allow(missing_debug_implementations)]
pub struct MappedFactory<Inner: InputMap> {
    translators: Vec<ValueGetter<Inner, Inner::Error>>,
}

impl<M: InputMap> AssociatedEventFactory for M {
    type Factory = MappedFactory<M>;
}
impl<Inner: InputMap> EventFactory for MappedFactory<Inner> {
    type CreationData = Inner::CreationData;
    type Error = Inner::Error;
    type Record = Inner;

    fn try_new(
        map: HashMap<String, InputReference>,
        setup_data: Self::CreationData,
    ) -> Result<(Self, Vec<String>), EventFactoryError> {
        let mut translators: Vec<Option<_>> = (0..map.len()).map(|_| None).collect();
        let mut found = Vec::with_capacity(map.len());
        let default_fn = Box::new(|_r: &Inner| Ok(Value::None));
        for (input_name, index) in map {
            match Inner::func_for_input(input_name.as_str(), setup_data.clone()) {
                Ok(projection) => {
                    translators[index] = Some(projection);
                    found.push(input_name.clone());
                },
                Err(e) => {
                    let ie: EventFactoryError = e.into();
                    if matches!(ie, EventFactoryError::InputStreamUnknown(_)) {
                        translators[index] = Some(default_fn.clone())
                    } else {
                        return Err(ie);
                    }
                },
            }
        }
        let translators = translators.into_iter().map(Option::unwrap).collect();
        Ok((Self { translators }, found))
    }

    fn get_event(&self, rec: Inner) -> Result<Event, EventFactoryError> {
        self.translators.iter().map(|f| f(&rec).map_err(|e| e.into())).collect()
    }
}

#[derive(Debug, Clone, Copy)]
/// An error type for the [ArrayFactory]
pub struct ArrayFactoryError<I: Error + Send + 'static>(I);
impl<I: Error + Send + 'static> Display for ArrayFactoryError<I> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        <I as Display>::fmt(&self.0, f)
    }
}
impl<I: Error + Send + 'static> Error for ArrayFactoryError<I> {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(&self.0)
    }
}
impl<I: Error + Send + 'static> From<ArrayFactoryError<I>> for EventFactoryError {
    fn from(value: ArrayFactoryError<I>) -> Self {
        Self::Other(Box::new(value.0))
    }
}
/// The simplest input method to the monitor. It accepts any type that can be turned into `[Value; N]` where `N` is ideally the number of input streams.
/// If N is smaller than the number of windows the array is extended with `Value::None`.
/// The conversion to values and the order of inputs must be handled externally.
#[derive(Debug, Clone)]
pub struct ArrayFactory<
    const N: usize,
    I: Error + Send + 'static,
    E: TryInto<[Value; N], Error = I> + CondSerialize + CondDeserialize,
> {
    num_inputs: usize,
    phantom: PhantomData<E>,
}

impl<
        const N: usize,
        I: Error + Send + 'static,
        E: TryInto<[Value; N], Error = I> + Send + CondSerialize + CondDeserialize,
    > EventFactory for ArrayFactory<N, I, E>
{
    type CreationData = ();
    type Error = ArrayFactoryError<I>;
    type Record = E;

    fn try_new(
        map: HashMap<String, InputReference>,
        _setup_data: Self::CreationData,
    ) -> Result<(Self, Vec<String>), EventFactoryError> {
        let num_inputs = map.len();
        let found: Vec<_> = map
            .into_iter()
            .sorted_by(|a, b| Ord::cmp(&a.1, &b.1))
            .map(|(name, _)| name)
            .take(N)
            .collect();
        Ok((
            ArrayFactory {
                num_inputs,
                phantom: PhantomData,
            },
            found,
        ))
    }

    fn get_event(&self, rec: Self::Record) -> Result<Event, EventFactoryError> {
        let arr = rec.try_into().map_err(ArrayFactoryError)?;
        let mut v = Vec::from(arr);
        // Fill rest of the event with nones;
        v.resize(self.num_inputs, Value::None);
        Ok(v)
    }
}

#[derive(Debug, Clone, Copy)]
/// An error type for the [VectorFactory]
pub enum VectorFactoryError<I: Error + Send + 'static> {
    /// Error while creating the Vector in the [VectorFactory]
    Inner(I),
    /// Size of the generated ``Vec<Value>`` is different from the specified size while creating the [VectorFactory]
    InvalidSize {
        #[allow(missing_docs)]
        expected: usize,
        #[allow(missing_docs)]
        got: usize,
    },
}
impl<I: Error + Send + 'static> Display for VectorFactoryError<I> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            VectorFactoryError::Inner(inner) => <I as Display>::fmt(inner, f),
            VectorFactoryError::InvalidSize { expected, got } => {
                write!(f, "Invalid size(expected: {expected}, got: {got})")
            },
        }
    }
}
impl<I: Error + Send + 'static> Error for VectorFactoryError<I> {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            VectorFactoryError::Inner(i) => Some(i),
            VectorFactoryError::InvalidSize { .. } => None,
        }
    }
}
impl<I: Error + Send + 'static> From<VectorFactoryError<I>> for EventFactoryError {
    fn from(value: VectorFactoryError<I>) -> Self {
        Self::Other(Box::new(value))
    }
}

/// One of the simplest input method to the monitor. It accepts any type that can be turned into `Vec<Value>`.
/// If the length of the vector is smaller than the number of windows the vector is extended with `Value::None`.
/// The conversion to values and the order of inputs must be handled externally. When creating the [VectorFactory]
/// the user must provide the length of the vector that is returned in the conversion. The implementation then checks
/// dynamically if this size is satisfied.
#[derive(Debug, Clone)]
pub struct VectorFactory<I: Error + Send + 'static, E: TryInto<Vec<Value>, Error = I> + CondSerialize + CondDeserialize>
{
    num_inputs: usize,
    len_vector: usize,
    phantom: PhantomData<E>,
}

impl<I: Error + Send + 'static, E: TryInto<Vec<Value>, Error = I> + Send + CondSerialize + CondDeserialize> EventFactory
    for VectorFactory<I, E>
{
    type CreationData = usize;
    type Error = VectorFactoryError<I>;
    type Record = E;

    fn try_new(
        map: HashMap<String, InputReference>,
        setup_data: Self::CreationData,
    ) -> Result<(Self, Vec<String>), EventFactoryError> {
        let num_inputs = map.len();
        let len_vector = setup_data;
        let found: Vec<_> = map
            .into_iter()
            .sorted_by(|a, b| Ord::cmp(&a.1, &b.1))
            .map(|(name, _)| name)
            .take(len_vector)
            .collect();
        Ok((
            Self {
                num_inputs,
                len_vector,
                phantom: PhantomData,
            },
            found,
        ))
    }

    fn get_event(&self, rec: Self::Record) -> Result<Event, EventFactoryError> {
        let mut vec: Vec<_> = rec.try_into().map_err(VectorFactoryError::Inner)?;
        if vec.len() != self.len_vector {
            Err(VectorFactoryError::<I>::InvalidSize {
                expected: self.len_vector,
                got: vec.len(),
            }
            .into())
        } else {
            // Fill rest of the event with nones;
            vec.resize(self.num_inputs, Value::None);
            Ok(vec)
        }
    }
}

impl AssociatedEventFactory for Vec<Value> {
    type Factory = VectorFactory<Infallible, Vec<Value>>;
}

/// A dummy event factory, that never produces a value for an input stream.
#[derive(Debug, Copy, Clone)]
pub struct EmptyFactory<T: Send>(usize, PhantomData<T>);

/// A type that represents the event in which no input streams gets a new value
#[derive(Debug, Copy, Clone, Default)]
pub struct NoEvent;

impl<T: Send> EventFactory for EmptyFactory<T> {
    type CreationData = ();
    type Error = Infallible;
    type Record = T;

    fn try_new(
        map: HashMap<String, InputReference>,
        _setup_data: Self::CreationData,
    ) -> Result<(Self, Vec<String>), EventFactoryError> {
        Ok((Self(map.len(), PhantomData), vec![]))
    }

    fn get_event(&self, _rec: Self::Record) -> Result<Event, EventFactoryError> {
        Ok(vec![Value::None; self.0])
    }
}

impl AssociatedEventFactory for NoEvent {
    type Factory = EmptyFactory<NoEvent>;
}
