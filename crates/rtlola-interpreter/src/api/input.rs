//! This module contains necessary traits and types to interface your datastructures with the interpreter.
//! Most notably, the [Input] trait represents a factory for events such that you can feed events of type [Input::Record] to the monitor.
//! To easy the implementation, there are helper traits like [Record] which works together with the [RecordInput].
//!
//! Note: A struct implementing [Input] for a given type can often be derived. For that take a look at the rtlola-interpreter-macros crate and the [DerivedInput] trait.

// ######## Traits ############

use std::collections::{HashMap, HashSet};
use std::convert::Infallible;
use std::error::Error;
use std::fmt::{Display, Formatter};
use std::marker::PhantomData;

use itertools::izip;
use paste::paste;
use rtlola_frontend::mir::InputReference;

use crate::monitor::Event;
use crate::{CondDeserialize, CondSerialize, Value, ValueConvertError};

/// This trait provides the functionality to pass inputs to the monitor.
/// You can either implement this trait for your own Datatype or use one of the predefined input methods.
/// See [RecordInput] and [EventInput]
pub trait Input: Sized {
    /// The type from which an event is generated by the input source.
    type Record: Send;

    /// The error type returned by the input source on IO errors or parsing issues.
    type Error: Into<InputError> + Send + 'static;

    /// Arbitrary type of the data provided to the input source at creation time.
    type CreationData: Clone + Send;

    /// Creates a new input source from a HashMap mapping the names of the inputs in the specification to their position in the event.
    fn new(map: HashMap<String, InputReference>, setup_data: Self::CreationData) -> Result<Self, InputError> {
        let all = map.keys().cloned().collect::<HashSet<_>>();
        let (i, found) = Self::try_new(map, setup_data)?;
        let found = found.into_iter().collect::<HashSet<_>>();
        let missing: Vec<String> = all.difference(&found).cloned().collect();
        if !missing.is_empty() {
            Err(InputError::InputStreamUnknown(missing))
        } else {
            Ok(i)
        }
    }

    /// Construction the input for only a subset of the required input streams. Enables the combination of multiple Input implementors into one.
    /// The returned Vector contains the names of the input streams that can be served by this input.
    /// The constructed input should return `Value::None` for all inputs that are unknown to it.
    fn try_new(
        map: HashMap<String, InputReference>,
        setup_data: Self::CreationData,
    ) -> Result<(Self, Vec<String>), InputError>;

    /// This function converts a record to an event.
    fn get_event(&self, rec: Self::Record) -> Result<Event, InputError>;
}

/// This trait provides functionality to parse a record into an event.
/// It is only used in combination with the [RecordInput].
pub trait Record: Send {
    /// Arbitrary type of the data provided at creation time to help initializing the input method.
    type CreationData: Clone + Send;
    /// The error returned if anything goes wrong.
    type Error: Into<InputError> + Send + 'static;
    /// Given the name of an input this function returns a function that given a record returns the value for that input.
    fn func_for_input(name: &str, data: Self::CreationData) -> Result<ValueProjection<Self, Self::Error>, Self::Error>;
}

/// A helper trait to get the generated type that implements the [Input] trait for an enum that derives it.
pub trait DerivedInput {
    /// The type generated by the derive macro
    type Input: Input;
}

// ######## Implementation ######################

/// A function Type that projects a reference to `From` to a `Value`
pub type ValueProjection<From, E> = Box<dyn (Fn(&From) -> Result<Value, E>)>;

#[derive(Debug)]
/// A generic Error to be used
pub enum InputError {
    /// Could not find an associated struct field for the input streams.
    InputStreamUnknown(Vec<String>),
    /// The value of the struct field is not supported by the interpreter.
    ///
    /// *Help*: ```TryFrom<YourType> for Value``` has to be implemented.
    ValueNotSupported(ValueConvertError),
    /// The variant of the enum identified by the string was ignored when deriving the Input, yet it was received as an input.
    VariantIgnored(String),
    /// An unknown error occurred
    Other(Box<dyn Error + Send + 'static>),
}
impl Display for InputError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            InputError::InputStreamUnknown(name) => {
                write!(
                    f,
                    "The following input stream(s) cannot be served by the input: {}",
                    name.join(", ")
                )
            },
            InputError::ValueNotSupported(val) => {
                write!(f, "The type of {val:?} is not supported by the interpreter.")
            },
            InputError::Other(e) => {
                write!(f, "RecordError: {e}.")
            },
            InputError::VariantIgnored(variant) => {
                write!(f, "Received ignored variant: {variant}.")
            },
        }
    }
}
impl Error for InputError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            InputError::InputStreamUnknown(_) | InputError::ValueNotSupported(_) | InputError::VariantIgnored(_) => {
                None
            },
            InputError::Other(e) => Some(e.as_ref()),
        }
    }
}
impl From<ValueConvertError> for InputError {
    fn from(value: ValueConvertError) -> Self {
        InputError::ValueNotSupported(value)
    }
}
impl From<Infallible> for InputError {
    fn from(_value: Infallible) -> Self {
        unreachable!()
    }
}

/// An input method for types that implement the [Record] trait. Useful if you do not want to bother with the order of the input streams in an event.
/// Assuming the specification has 3 inputs: 'a', 'b' and 'c'. You could implement this trait for your custom 'MyType' as follows:
/// ```
/// use std::fmt::Formatter;
///
/// use rtlola_interpreter::input::{InputError, Record};
/// use rtlola_interpreter::Value;
/// #[cfg(feature = "serde")]
/// use serde::{Deserialize, Serialize};
///
/// #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
/// struct MyType {
///     a: u64,
///     b: Option<bool>,
///     c: String,
/// }
///
/// impl MyType {
///     // Generate a new value for input stream 'a'
///     fn a(rec: &Self) -> Result<Value, InputError> {
///         Ok(Value::from(rec.a))
///     }
///
///     // Generate a new value for input stream 'b'
///     fn b(rec: &Self) -> Result<Value, InputError> {
///         Ok(rec.b.map(|b| Value::from(b)).unwrap_or(Value::None))
///     }
///
///     // Generate a new value for input stream 'c'
///     fn c(rec: &Self) -> Result<Value, InputError> {
///         Ok(Value::Str(rec.c.clone().into_boxed_str()))
///     }
/// }
///
/// impl Record for MyType {
///     type CreationData = ();
///     type Error = InputError;
///
///     fn func_for_input(
///         name: &str,
///         _data: Self::CreationData,
///     ) -> Result<Box<dyn (Fn(&MyType) -> Result<Value, InputError>)>, InputError> {
///         match name {
///             "a" => Ok(Box::new(Self::a)),
///             "b" => Ok(Box::new(Self::b)),
///             "c" => Ok(Box::new(Self::c)),
///             x => Err(InputError::InputStreamUnknown(vec![x.to_string()])),
///         }
///     }
/// }
/// ```
#[allow(missing_debug_implementations)]
pub struct RecordInput<Inner: Record> {
    translators: Vec<ValueProjection<Inner, Inner::Error>>,
}

impl<R: Record> DerivedInput for R {
    type Input = RecordInput<R>;
}
impl<Inner: Record> Input for RecordInput<Inner> {
    type CreationData = Inner::CreationData;
    type Error = Inner::Error;
    type Record = Inner;

    fn try_new(
        map: HashMap<String, InputReference>,
        setup_data: Self::CreationData,
    ) -> Result<(Self, Vec<String>), InputError> {
        let mut translators: Vec<Option<_>> = (0..map.len()).map(|_| None).collect();
        let mut found = Vec::with_capacity(map.len());
        let default_fn = Box::new(|_r: &Inner| Ok(Value::None));
        for (input_name, index) in map {
            match Inner::func_for_input(input_name.as_str(), setup_data.clone()) {
                Ok(projection) => {
                    translators[index] = Some(projection);
                    found.push(input_name.clone());
                },
                Err(e) => {
                    let ie: InputError = e.into();
                    if matches!(ie, InputError::InputStreamUnknown(_)) {
                        translators[index] = Some(default_fn.clone())
                    } else {
                        return Err(ie);
                    }
                },
            }
        }
        let translators = translators.into_iter().map(Option::unwrap).collect();
        Ok((Self { translators }, found))
    }

    fn get_event(&self, rec: Inner) -> Result<Event, InputError> {
        self.translators.iter().map(|f| f(&rec).map_err(|e| e.into())).collect()
    }
}

#[derive(Debug, Clone, Copy)]
/// An error type for the [EventInput]
pub struct EventInputError<I: Error + Send + 'static>(I);
impl<I: Error + Send + 'static> Display for EventInputError<I> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        <I as Display>::fmt(&self.0, f)
    }
}
impl<I: Error + Send + 'static> Error for EventInputError<I> {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(&self.0)
    }
}
impl<I: Error + Send + 'static> From<EventInputError<I>> for InputError {
    fn from(value: EventInputError<I>) -> Self {
        Self::Other(Box::new(value.0))
    }
}
/// The simplest input method to the monitor. It accepts any type that implements `Into<Event>`.
/// The conversion to values and the order of inputs must be handled externally.
#[derive(Debug, Clone)]
pub struct EventInput<
    const N: usize,
    I: Error + Send + 'static,
    E: TryInto<[Value; N], Error = I> + CondSerialize + CondDeserialize,
> {
    phantom: PhantomData<E>,
}

impl<
        const N: usize,
        I: Error + Send + 'static,
        E: TryInto<[Value; N], Error = I> + Send + CondSerialize + CondDeserialize,
    > Input for EventInput<N, I, E>
{
    type CreationData = ();
    type Error = EventInputError<I>;
    type Record = E;

    fn try_new(
        map: HashMap<String, InputReference>,
        _setup_data: Self::CreationData,
    ) -> Result<(Self, Vec<String>), InputError> {
        Ok((EventInput { phantom: PhantomData }, map.into_keys().take(N).collect()))
    }

    fn get_event(&self, rec: Self::Record) -> Result<Event, InputError> {
        let arr = rec.try_into().map_err(EventInputError)?;
        Ok(Vec::from(arr))
    }
}

macro_rules! tuple_input_impls {
    ($num:expr, $( $name:ident )+ ) => {
        paste!{
            #[doc=concat!("Implements [Input] for a ", stringify!($num), "-tuple of types that implement [DerivedInput]")]
            #[allow(missing_debug_implementations)]
            pub struct [<TupleInput $num>]<
                $([<$name I>]: Input<CreationData = (), Record = $name>),+,
                $($name: DerivedInput<Input = [<$name I>]> + Send),+
            > {
                $([<$name:lower>]: [<$name I>]),+
            }

            impl<
                $([<$name I>]: Input<CreationData = (), Record = $name>),+,
                $($name: DerivedInput<Input = [<$name I>]> + Send),+
                > Input for[<TupleInput $num>]<$([<$name I>]),+,$($name),+>
            {
                type CreationData = ();
                type Error = InputError;
                type Record = ($($name),+);

                fn try_new(
                    map: HashMap<String, InputReference>,
                    _setup_data: Self::CreationData,
                ) -> Result<(Self, Vec<String>), InputError> {
                    let mut total_found: HashSet<String> = map.keys().cloned().collect();
                    $(
                        let ([<$name:lower>], found) = [<$name I>]::try_new(map.clone(), ())?;
                        total_found.extend(found);
                    )+
                    Ok((Self { $([<$name:lower>]),+ }, total_found.into_iter().collect()))
                }

                fn get_event(&self, rec: Self::Record) -> Result<Event, InputError> {
                    let ($([<$name:lower _rec>]),+) = rec;
                    $(
                        let [<$name:lower _event>] = self.[<$name:lower>].get_event([<$name:lower _rec>])?;
                    )+
                    Ok(izip!($([<$name:lower _event>]),+).map(|($([<$name:lower>]),+)| Value::None$(.and_then([<$name:lower>]))+).collect())
                }
            }

            impl<
                $([<$name I>]: Input<CreationData = (), Record = $name>),+,
                $($name: DerivedInput<Input = [<$name I>]> + Send),+
                > DerivedInput for ($($name),+) {
                type Input = [<TupleInput $num>]<
                                $([<$name I>]),+,
                                $($name),+
                            > ;
            }
        }
    };
}

tuple_input_impls! {2, A B }
